# ------------------------------------------------------------------------------------
# Helper to use CPPAST from outside project
#
# CPPAST_FOUND
# CPPAST_INCLUDE_DIRS is filled with CPPAST and available 3rdparty headers
# CPPAST_LIBRARY_DIRS is filled with CPPAST components libraries install directory and 3rdparty libraries paths
# CPPAST_LIBRARIES
# CPPAST_DEFINITIONS
#------------------------------------------------------------------------------------
#  Usage from an external project:
#    In your CMakeLists.txt, add these lines:
#
#    find_package(cppast REQUIRED)
#    target_link_libraries(MY_TARGET_NAME PUBLIC cppast)

@PACKAGE_INIT@

set_and_check(CPPAST_CMAKE_DIR "@PACKAGE_CPPAST_CMAKE_DIR@")

# Set default policy behavior similar to minimum requirement version
# cmake_policy(VERSION 3.8)

# explicitly set policies we already support in newer cmake versions
if(POLICY CMP0074)
  # TODO: update *_ROOT variables to be CPPAST_*_ROOT or equivalent.
  # CMP0074 directly affects how Find* modules work and *_ROOT variables.  Since
  # this is a config file that will be consumed by parent projects with (likely)
  # NEW behavior, we need to push a policy stack.
  cmake_policy(SET CMP0074 NEW)
endif()

# https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html

### ---[ Find CPPAST
#if(CPPAST_FIND_QUIETLY)
#  set(QUIET_ QUIET)
#else()
#  set(QUIET_)
#endif()
if (cppast_FIND_QUIETLY) 
  set(QUIET_OR_REQUIRED_OPTION "QUIET")
elseif (cppast_FIND_REQUIRED) 
  set(QUIET_OR_REQUIRED_OPTION "REQUIRED")
else ()
  set(QUIET_OR_REQUIRED_OPTION "")
endif()

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CPPAST_CMAKE_DIR}/modules)

message(STATUS ${CPPAST_ROOT})
# check whether CPPASTConfig.cmake is found into a CPPAST installation or in a build tree
if(EXISTS "${CPPAST_ROOT}/include/cppast_config.h")
  # Found a CPPAST installation
  message(STATUS "Found a CPPAST installation")
  set(CPPAST_CONF_INCLUDE_DIR "${CPPAST_ROOT}/include")
  set(CPPAST_LIBRARY_DIRS "${CPPAST_ROOT}/lib")
  set(CPPAST_LIBRARIES "cppast;_cppast_tiny_process")
  # set(CPPAST_DEFINITIONS
else()
  message(STATUS "CPPAST can not be found on this machine")
endif()

#set(CPPAST_INCLUDE_DIRS "${CPPAST_CONF_INCLUDE_DIR}")

# Load the dependencies for the libraries of @PROJECT_NAME@
# (contains definitions for IMPORTED targets). This is only
# imported if we are not built as a subproject (in this case targets are already there)
IF(NOT TARGET Event AND NOT @PROJECT_NAME@_BINARY_DIR)
  INCLUDE("@PACKAGE_CPPAST_INSTALL_CMAKE@/@PROJECT_NAME@-target.cmake")
ENDIF()

#set a suffix for debug libraries
set(CPPAST_DEBUG_SUFFIX "@CMAKE_DEBUG_POSTFIX@")
set(CPPAST_RELEASE_SUFFIX "@CMAKE_RELEASE_POSTFIX@")



include(FindPackageHandleStandardArgs)

set(CPPAST_INCLUDE_DIR   "@CMAKE_INSTALL_FULL_INCLUDEDIR@" )
#set(CPPAST_ICONS_DIR   "@CMAKE_INSTALL_PREFIX@/share/icons" )
#set(CPPAST_CONFIG_DIR  "${installedPrefix}/@CONFIG_INSTALL_DIR@" )

# Package root dir:
SET_AND_CHECK(GUI_ROOT_DIR_EXP "@PACKAGE_CMAKE_INSTALL_PREFIX@")

check_required_components(cppast)