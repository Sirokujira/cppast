# ------------------------------------------------------------------------------------
# Helper to use CPPAST from outside project
#
# CPPAST_FOUND
# CPPAST_INCLUDE_DIRS is filled with CPPAST and available 3rdparty headers
# CPPAST_LIBRARY_DIRS is filled with CPPAST components libraries install directory and 3rdparty libraries paths
# CPPAST_LIBRARIES
# CPPAST_DEFINITIONS
#------------------------------------------------------------------------------------
#  Usage from an external project:
#    In your CMakeLists.txt, add these lines:
#
#    find_package(cppast REQUIRED)
#    target_link_libraries(MY_TARGET_NAME PUBLIC cppast)

@PACKAGE_INIT@

include(FindPackageHandleStandardArgs)

set_and_check(CPPAST_INCLUDE_DIRS   "@CMAKE_INSTALL_FULL_INCLUDEDIR@" )
set_and_check(CPPAST_LIBRARY_DIRS   "@CMAKE_INSTALL_PREFIX@/lib")
#set_and_check(CPPAST_ICONS_DIR      "@CMAKE_INSTALL_PREFIX@/share/icons" )
#set_and_check(CPPAST_CONFIG_DIR     "${installedPrefix}/@CONFIG_INSTALL_DIR@" )
set_and_check(CPPAST_CMAKE_DIR "@CMAKE_INSTALL_PREFIX@/lib/cmake/@PROJECT_NAME@")

set(CPPAST_LIBRARIES      "cppast;_cppast_tiny_process")

# Set default policy behavior similar to minimum requirement version
# cmake_policy(VERSION 3.8)

# explicitly set policies we already support in newer cmake versions
if(POLICY CMP0074)
  # TODO: update *_ROOT variables to be CPPAST_*_ROOT or equivalent.
  # CMP0074 directly affects how Find* modules work and *_ROOT variables.  Since
  # this is a config file that will be consumed by parent projects with (likely)
  # NEW behavior, we need to push a policy stack.
  cmake_policy(SET CMP0074 NEW)
endif()

# https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html

### ---[ Find CPPAST
#if(CPPAST_FIND_QUIETLY)
#  set(QUIET_ QUIET)
#else()
#  set(QUIET_)
#endif()
if (cppast_FIND_QUIETLY) 
  set(QUIET_OR_REQUIRED_OPTION "QUIET")
elseif (cppast_FIND_REQUIRED) 
  set(QUIET_OR_REQUIRED_OPTION "REQUIRED")
else ()
  set(QUIET_OR_REQUIRED_OPTION "")
endif()

set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CPPAST_CMAKE_DIR}/modules)

# Provide all our library targets to users.
# include("${CMAKE_MODULE_PATH}/Finddebug_assert.cmake")
# include("${CMAKE_MODULE_PATH}/Findtype_safe.cmake")

message(STATUS ${CPPAST_ROOT})
# check whether CPPASTConfig.cmake is found into a CPPAST installation or in a build tree
if(EXISTS "${CPPAST_ROOT}/include/cppast_config.h")
  # Found a CPPAST installation
  message(STATUS "Found a CPPAST installation")
  set(CPPAST_CONF_INCLUDE_DIR "${CPPAST_ROOT}/include")
  set(CPPAST_LIBRARY_DIRS "${CPPAST_ROOT}/lib")
  set(CPPAST_LIBRARIES "cppast;_cppast_tiny_process")
  # set(CPPAST_DEFINITIONS
else()
  message(STATUS "CPPAST can not be found on this machine")
endif()

#set(CPPAST_INCLUDE_DIRS "${CPPAST_CONF_INCLUDE_DIR}")

# Load the dependencies for the libraries of @PROJECT_NAME@
# (contains definitions for IMPORTED targets). This is only
# imported if we are not built as a subproject (in this case targets are already there)
if(NOT TARGET Event AND NOT @PROJECT_NAME@_BINARY_DIR)
  include("${CPPAST_CMAKE_DIR}/@PROJECT_NAME@-targets.cmake")
endif()

#set a suffix for debug libraries
set(CPPAST_DEBUG_SUFFIX "@CMAKE_DEBUG_POSTFIX@")
set(CPPAST_RELEASE_SUFFIX "@CMAKE_RELEASE_POSTFIX@")

message(STATUS ${CPPAST_LIBRARY_DIRS})
message(STATUS ${CPPAST_LIBRARIES})
message(STATUS ${CPPAST_DEBUG_ASSERT_INCLUDE_DIRS})
message(STATUS ${CPPAST_TYPE_SAFE_INCLUDE_DIRS})

# Package root dir:
# set_and_check(GUI_ROOT_DIR_EXP "@PACKAGE_CMAKE_INSTALL_PREFIX@")

include(${CMAKE_CURRENT_LIST_DIR}/@targets_export_name@.cmake)
check_required_components(cppast)